## 3.1 TCP

### 3.1.1 TCP定义

TCP（Transmission Control Protocol 传输控制协议）是一种**面向连接的、可靠的、基于字节流**的传输层通信协议，由IETF的RFC 793定义。

### 3.1.2 TCP特性

#### 1. 面向连接

TCP通信需要经过创建连接、数据传送、终止连接三个步骤。TCP通信模型中，在通信开始之前，一定要先建立相关的链接，才能发送数据，类似于生活中，"打电话"。通信双方必须先建立连接（打通电话）才能进行数据的传输（交流），双方都必须为该连接分配必要的系统内核资源，以管理连接的状态和连接上的传输。双方间的数据传输都可以通过这一个连接进行。完成数据交换后，双方必须断开此连接（挂掉电话），以释放系统资源。这种连接是一对一的，因此TCP不适用于广播的应用程序，基于广播的应用程序请使用UDP协议。

![](/assets/dadianhua.png)

#### 2. 可靠传输

**1）TCP采用发送应答机制**  
TCP发送的每个报文段都必须得到接收方的应答才认为这个TCP报文段传输成功  
**2）超时重传**  
发送端发出一个报文段之后就启动定时器，如果在定时时间内没有收到应答就重新发送这个报文段。TCP为了保证不发生丢包，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的包发回一个相应的确认（ACK）；如果发送端实体在合理的往返时延（RTT）内未收到确认，那么对应的数据包就被假设为已丢失将会被进行重传。  
**3）错误校验**  
TCP用一个校验和函数来检验数据是否有错误；在发送和接收时都要计算校验和。  
**4\) 流量控制和阻塞管理**  
流量控制用来避免主机发送得过快而使接收方来不及完全收下。

### 3.1.3 TCP通信的三次握手和四次挥手

#### 连接建立

TCP是因特网中的传输层协议，使用三次握手协议建立连接。当主动方发出SYN连接请求后，等待对方回答SYN+ACK，并最终对对方的 SYN 执行 ACK 确认。这种建立连接的方法可以防止产生错误的连接，TCP使用的流量控制协议是可变大小的滑动窗口协议。

**TCP三次握手**的过程如下：  
客户端发送SYN（SEQ=x）报文给服务器端，进入SYN\_SEND状态。  
服务器端收到SYN报文，回应一个SYN （SEQ=y）ACK\(ACK=x+1）报文，进入SYN\_RECV状态。  
客户端收到服务器端的SYN报文，回应一个ACK\(ACK=y+1）报文，进入Established状态。  
**三次握手完成，TCP客户端和服务器端成功地建立连接，可以开始传输数据了**。

`这就像最经典的打电话方式:我们向10086打人工电话时，需要接通到人工状态；10086客服人员会回应我们‘有什么需要服务的吗？’然后等待我们回复；我们听到10086客服的声音后，回复‘有’。总共3次握手，接下来就是沟通解决问题了。`

#### ![](/assets/tcp_sanciwoshou.png)

#### 连接终止

**建立一个连接需要三次握手，而终止一个连接要经过四次握手**，这是由TCP的半关闭（half-close）造成的。具体过程如下图所示。

\(1\) 某个应用进程首先调用close，称该端执行“主动关闭”（active close）。该端的TCP于是发送一个FIN分节，表示数据发送完毕。\(2\) 接收到这个FIN的对端执行 “被动关闭”（passive close），这个FIN由TCP确认。

`注意：FIN的接收也作为一个文件结束符（end-of-file）传递给接收端应用进程，放在已排队等候该应用进程接收的任何其他数据之后，因为，FIN的接收意味着接收端应用进程在相应连接上再无额外数据可接收。`

\(3\) 一段时间后，接收到这个文件结束符的应用进程将调用close关闭它的套接字。这导致它的TCP也发送一个FIN。  
\(4\) 接收这个最终FIN的原发送端TCP（即执行主动关闭的那一端）确认这个FIN。

既然每个方向都需要一个FIN和一个ACK，因此通常需要4个分节。

`这就像我们拨打10086人工客服服务结束的时候：      
我们会对10086客服人员说，谢谢您解答了我的这个问题；      
10086客服人员会回应我们'很高兴为您解答，还有其他问题么？如果没有的话，请帮忙进行评价'——这里面两个意思，一个是对我们上一句话的应答，另一个是确认问询；      
我们会再次恢复10086客服人员，没有问题了，非常感谢，一定评10分。结束通话`

![](/assets/tcp_sicihuishou.png)

**注意：**

\(1\) “通常”是指，某些情况下，步骤1的FIN随数据一起发送，另外，步骤2和步骤3发送的分节都出自执行被动关闭那一端，有可能被合并成一个分节。  
\(2\) 在步骤2与步骤3之间，从执行被动关闭一端到执行主动关闭一端流动数据是可能的，这称为“半关闭”（half-close）。  
\(3\) 当一个Unix进程无论自愿地（调用exit或从main函数返回）还是非自愿地（收到一个终止本进程的信号）终止时，所有打开的描述符都被关闭，这也导致仍然打开的任何TCP连接上也发出一个FIN。  
无论是客户还是服务器，任何一端都可以执行主动关闭。**通常情况是，客户执行主动关闭，但是某些协议，例如，HTTP/1.0却由服务器执行主动关闭。**



