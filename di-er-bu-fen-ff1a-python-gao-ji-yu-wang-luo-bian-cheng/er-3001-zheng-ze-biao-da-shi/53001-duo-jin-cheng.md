# 5 多线程

在我们UDP那一章，聊天器实例的发送消息和接收消息是同步的，然而QQ可以同时收发消息耶，为什么呢？这就是接下来学习的动力。

## 5.1 多线程概念引入

在现实生活中很多事情都是同时进行的，比如开车时我们的手握着方向盘、脚踩着档位以实现驾驶汽车的一些操作，这两个动作是同时进行的。除此之外就像唱歌跳舞那样，很多演唱会的明星都是在唱歌时，舞台上伴随着舞蹈。想象一下，如果一个很一般的歌手，自己先向大家唱完歌，然后不会跳舞的他再给大家跳一段属于那首歌的舞蹈，那这个演唱会就太失败了，除非他是杰克逊。接下来我们用程序模拟下唱歌跳舞。

```py
'''net03_sing_dance.py'''
import time


def sing():
    for i in range(5):
        print('正在唱歌呢 %d' % i)
        time.sleep(1) # 休息1秒


def dance():
    for i in range(5):
        print('正在跳舞呢 %d' % i)
        time.sleep(1) # 休息1秒

if __name__ == '__main__':
    sing() # 唱歌
    dance() # 跳舞
```

这段代码中，我们定义了一个唱歌函数和一个跳舞函数，里面用print语句模拟正在进行的状态，为了更好的再后续分析，我们让其每次在中间休息1s中。

![](/assets/threading0.png)

从执行结果来看，唱完歌之后才会去跳舞。为什么呢？就像下图左边那样，我们的程序串行的执行了所有任务；而生活中往往需要我们同时处理两个任务，就像下图右边那样，即多任务处理。多任务处理中有种叫做线程的东西可以帮我们实现这样的想法。

![](/assets/threading1.png)

请看定义：**线程是程序中一个单一的顺序控制流程**。进程内有一个相对独立的、可调度的执行单元，是系统独立调度和分派CPU的基本单位指令运行时的程序的调度单位。**在单个程序中同时运行多个线程完成不同的工作，称为多线程。**

从定义中可以看出我们之前的那段代码是一个单一的顺序控制流程，即单线程程序。为了实现同时唱歌和跳舞，若采用线程实现，我们必须编写多线程程序。请看下面这段代码。

```py
'''net03_sing_dance_threading.py'''
import time
import threading

def sing():
    for i in range(5):
        print('正在唱歌呢 %d' % i)
        time.sleep(1) # 休息1秒


def dance():
    for i in range(5):
        print('正在跳舞呢 %d' % i)
        time.sleep(1) # 休息1秒

if __name__ == '__main__':
    td1 = threading.Thread(target=sing)  # 创建唱歌子线程
    td2 = threading.Thread(target=dance) # 创建跳舞子线程
    td1.start() # 开始运行子线程
    td2.start() # 开始运行子线程
```

![](/assets/threading3.png)

从执行结果可以很清晰的看到唱歌和跳舞**似乎是在同时**交替进行，实现了我们的目的。为什么会这样呢？我们先不管python中的语法，先来清晰的了解下多线程的运行机制。

首先我们先了解下线程的几个状态。**线程有就绪、阻塞和运行三种基本状态。就绪状态是指线程具备运行的所有条件，逻辑上可以运行，在等待处理机；运行状态是指线程占有处理机正在运行；阻塞状态是指线程在等待一个事件（如某个信号量），逻辑上不可执行。**在我们上面的那段程序中，可以看到唱歌在执行时，每次都会休息1S，即唱歌线程从运行态进入了阻塞态；此时系统空闲下来了，多线程机制将空闲的资源用来执行跳舞；当跳舞又休息时，又返回来执行不休息的唱歌。就像下图所示那样。由于CPU处理的时间非常快，我们会感知上以为唱歌和跳舞是在同时运行。这就是多线程的基本流程，这样可以充分利用一些阻塞状态来实现资源的充分利用，提高效率。

![](/assets/threading4.png)

注：每一个程序都至少有一个线程，若程序只有一个线程，那就是程序本身。

