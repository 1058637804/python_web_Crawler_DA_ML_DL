# 5 多线程

在我们UDP那一章，聊天器实例的发送消息和接收消息是同步的，然而QQ可以同时收发消息耶，为什么呢？这就是接下来学习的动力。

## 5.1 多线程概念引入

在现实生活中很多事情都是同时进行的，比如开车时我们的手握着方向盘、脚踩着档位以实现驾驶汽车的一些操作，这两个动作是同时进行的。除此之外就像唱歌跳舞那样，很多演唱会的明星都是在唱歌时，舞台上伴随着舞蹈。想象一下，如果一个很一般的歌手，自己先向大家唱完歌，然后不会跳舞的他再给大家跳一段属于那首歌的舞蹈，那这个演唱会就太失败了，除非他是杰克逊。接下来我们用程序模拟下唱歌跳舞。

```py
'''net03_sing_dance.py'''
import time


def sing():
    for i in range(5):
        print('正在唱歌呢 %d' % i)
        time.sleep(1) # 休息1秒


def dance():
    for i in range(5):
        print('正在跳舞呢 %d' % i)
        time.sleep(1) # 休息1秒

if __name__ == '__main__':
    sing() # 唱歌
    dance() # 跳舞
```

这段代码中，我们定义了一个唱歌函数和一个跳舞函数，里面用print语句模拟正在进行的状态，为了更好的再后续分析，我们让其每次在中间休息1s中。

![](/assets/threading0.png)

从执行结果来看，唱完歌之后才会去跳舞。为什么呢？就像下图左边那样，我们的程序串行的执行了所有任务；而生活中往往需要我们同时处理两个任务，就像下图右边那样，即多任务处理。多任务处理中有种叫做线程的东西可以帮我们实现这样的想法。

![](/assets/threading1.png)

请看定义：**线程是程序中一个单一的顺序控制流程**。进程内有一个相对独立的、可调度的执行单元，是系统独立调度和分派CPU的基本单位指令运行时的程序的调度单位。**在单个程序中同时运行多个线程完成不同的工作，称为多线程。**

从定义中可以看出我们之前的那段代码是一个单一的顺序控制流程，即单线程程序。为了实现同时唱歌和跳舞，若采用线程实现，我们必须编写多线程程序。请看下面这段代码。

```py
'''net03_sing_dance_threading.py'''
import time
import threading

def sing():
    for i in range(5):
        print('正在唱歌呢 %d' % i)
        time.sleep(1) # 休息1秒


def dance():
    for i in range(5):
        print('正在跳舞呢 %d' % i)
        time.sleep(1) # 休息1秒

if __name__ == '__main__':
    td1 = threading.Thread(target=sing)  # 创建唱歌子线程
    td2 = threading.Thread(target=dance) # 创建跳舞子线程
    td1.start() # 开始运行子线程
    td2.start() # 开始运行子线程
```

![](/assets/threading3.png)

从执行结果可以很清晰的看到唱歌和跳舞**似乎是在同时**交替进行，实现了我们的目的。为什么会这样呢？我们先不管python中的语法，先来清晰的了解下多线程的运行机制。

首先我们先了解下线程的几个状态。**线程有就绪、阻塞和运行三种基本状态。就绪状态是指线程具备运行的所有条件，逻辑上可以运行，在等待处理机；运行状态是指线程占有处理机正在运行；阻塞状态是指线程在等待一个事件（如某个信号量），逻辑上不可执行。**在我们上面的那段程序中，可以看到唱歌在执行时，每次都会休息1S，即唱歌线程从运行态进入了阻塞态；此时系统空闲下来了，多线程机制将空闲的资源用来执行跳舞；当跳舞又休息时，又返回来执行不休息的唱歌。就像下图所示那样。由于CPU处理的时间非常快，我们会感知上以为唱歌和跳舞是在同时运行。这就是多线程的基本流程，这样可以充分利用一些阻塞状态来实现资源的充分利用，提高效率。

![](/assets/threading4.png)

注：每一个程序都至少有一个线程，若程序只有一个线程，那就是程序本身。

## 5.2 线程讲解

上一节我们通过唱歌和跳舞的实例向大家展示了线程的概念和魅力。本节我们具体说明下线程的由来、特点、适用范围等。

### 由来：

上世纪60年代，在操作系统中能拥有资源和独立运行的基本单位是进程，然而随着计算机技术的发展，进程出现了很多弊端，一是由于进程是资源拥有者，创建、撤消与切换存在较大的时空开销，因此需要引入轻型进程；二是由于对称多处理机（SMP）出现，可以满足多个运行单位，而多个进程并行开销过大。因此在80年代，出现了能独立运行的基本单位——线程（Threads）。

### 特性：

在多线程操作系统中，通常是在一个进程中包括多个线程，**每个线程都是作为利用CPU的基本单位**，是花费最小开销的实体。线程具有以下属性。

1）轻型实体

线程中的实体基本上不拥有系统资源，只是有一点必不可少的、能保证独立运行的资源。线程的实体包括程序、数据和TCB。线程是动态概念，它的动态特性由线程控制块TCB（Thread Control Block）描述。TCB包括以下信息：

（1）线程状态。  
（2）当线程不运行时，被保存的现场资源。  
（3）一组执行堆栈。  
（4）存放每个线程的局部变量主存区。  
（5）访问同一个进程中的主存和其它资源。  
用于指示被执行指令序列的程序计数器、保留局部变量、少数状态参数和返回地址等的一组寄存器和堆栈。

2）独立调度和分派的基本单位。

在多线程操作系统中，线程是能独立运行的基本单位，因而也是独立调度和分派的基本单位。由于线程很“轻”，故线程的切换非常迅速且开销小（在同一进程中的）。

**3）可并发执行。**

在一个进程中的多个线程之间，可以并发执行，甚至允许在一个进程中所有线程都能并发执行；同样，不同进程中的线程也能并发执行，充分利用和发挥了处理机与外围设备并行工作的能力。

**4）共享进程资源。**

在同一进程中的各个线程，都可以共享该进程所拥有的资源，这首先表现在：所有线程都具有相同的地址空间（进程的地址空间），这意味着，线程可以访问该地址空间的每一个虚地址；此外，还可以访问进程所拥有的已打开文件、定时器、信号量机构等。由于同一个进程内的线程共享内存和文件，所以线程之间互相通信不必调用内核。

### 与进程的比较：

**进程是资源分配的基本单位。**所有与该进程有关的资源，都被记录在进程控制块PCB中。以表示该进程拥有这些资源或正在使用它们。另外，进程也是抢占处理机的调度单位，它拥有一个完整的虚拟地址空间。当进程发生调度时，不同的进程拥有不同的虚拟地址空间，而同一进程内的不同线程共享同一地址空间。

与进程相对应，**线程与资源分配无关，它属于某一个进程**，并与进程内的其他线程一起共享进程的资源。

线程只由相关堆栈（系统栈或用户栈）寄存器和线程控制表TCB组成。寄存器可被用来存储线程内的局部变量，但不能存储其他线程的相关变量。

通常在一个进程中可以包含若干个线程，它们可以利用进程所拥有的资源。在引入线程的操作系统中，通常都是把进程作为分配资源的基本单位，而把线程作为独立运行和独立调度的基本单位。由于线程比进程更小，基本上不拥有系统资源，故对它的调度所付出的开销就会小得多，能更高效的提高系统内多个程序间并发执行的程度，从而显著提高系统资源的利用率和吞吐量。因而近年来推出的通用操作系统都引入了线程，以便进一步提高系统的并发性，并把它视为现代操作系统的一个重要指标。

**线程与进程的区别可以归纳为以下4点：**

1）地址空间和其它资源（如打开文件）：**进程间相互独立，同一进程的各线程间共享**。某进程内的线程在其它进程不可见。

2）通信：进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。

3）调度和切换：**线程上下文切换比进程上下文切换要快得多。**

4）在多线程操作系统中，进程不是一个可执行的实体。

## 5.3 在python中使用线程

**python中最常用的线程模块为threading，**可以完成多线程编写的大多数任务。目前除了个别UNIX不支持多线程外，基本上所有的python流行平台都支持线程了。接下来我们对照上一节那个同时唱歌跳舞的代码`net03_sing_dance_threading.py`。

**我们在使用threading时，最经典的方式是：一般需要先导入该模块；再通过threading中的Thread创建一个Thread对象；然后启动该线程start即可。**

```py
import threading
td1 = threading.Thread(target=sing)  # 创建唱歌子线程
td1.start() # 开始运行子线程
```

其中，Thread类的最常用语法如下：

```
threading.Thread(target=None, name=None, args=(), kwargs={})
```

* target赋值为要被调用的子进程对象
* name为将该进程自定义一个标识名称
* args为调用时传入的无名参数
* kwargs为调用时传入的有名参数

在threading中提供了查询当前进程中还运行的线程函数enumerate\(\)和当前运行线程数量的函数active\_count\(\)，我们向net03\_sing\_dance\_threading.py添加进如下代码。

```py
'''net03_threading_enumerate.py'''
    while True:
        length = len(threading.enumerate()) # 当前线程数量
        print('通过active_count查询到的线程数：', threading.active_count()) # 当前线程的数量
        print(threading.enumerate()) # 打印显示目前还存在的线程
        print('当前运行的线程数为：%d' % length)
        if length <= 1: # 除了两个子进程，还有默认的父进程，所以当唱歌跳舞执行完毕后，还剩一个线程
            break

        time.sleep(0.5)
```

![](/assets/threading5.png)

可以很清楚的看到，运行中总共有三个线程：

默认父线程：&lt;\_MainThread\(MainThread, started 140735499973440\)&gt;

子线程1：&lt;Thread\(Thread-1, started 123145313566720\)&gt;

子线程2：&lt;Thread\(Thread-2, started 123145318821888\)&gt;

当所有子线程结束时，才会结束父线程。

